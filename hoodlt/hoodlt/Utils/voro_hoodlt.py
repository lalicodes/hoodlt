"""
:module: compute voronoi tesselations using voro++
:platform: Unix, Windows
:synopsis: Utility to make voronoi tesselations

.. moduleauthor:: Alex Travesset <trvsst@ameslab.gov>, November2016
"""

from subprocess import call
import re
import numpy as np

from hoodlt.Utils.GeomClasses import VoroData
from hoodlt.Utils.Lattice_UnitCell import UnitCell


def make_voro_pp(lat):
    """
    Uses the package `Voro++ <http://math.lbl.gov/voro++/>`_
    to compute the Wigner-Seitz cell for a binary lattice with particles of different radii.
    The Voro++ must be compiled separately and should be available from the path that the program is executed.
    
    This program writes a number of intermediate files

    The program creates a number of intermediate files

    ==================   ======================
    File extension       Content
    ==================   ======================
    *_voro_input.vol     input file for Voro++
    *_voro_input         output file for Voro++
    ==================   ======================

    :param lat: :class:`hoodlt.D_matrix.Dmatrix_Mixt_Lattices.DMixtLattice`
    :return: Voronoi parameters of the unit cell
    :rtype: :class:`hoodlt.Utils.GeomClasses.VoroData`
    
    """

    # get lattice name
    fn = lat.name()[0]

    # this is the file that voro++ reads
    name = fn + '_voro_input'
    fid = open(name, 'w')

    lat_pnt = UnitCell(lat)

    for ind in range(lat_pnt.num_points):
        radius = lat_pnt.lat.radius[lat_pnt.indices_all[ind, 0]]
        pn = lat_pnt.pnts[ind]
        fid.write('%d %1.10f %1.10f %1.10f %1.10f\n' % (ind, pn[0], pn[1], pn[2], radius))
    fid.close()

    mat = lat_pnt.bounding_box()
    [xmin, ymin, zmin] = mat[0]
    [xmax, ymax, zmax] = mat[1]

    # command to be executed by voro++
    fl_opt = 'voro++ -v -r -c %i#%w#%g#%s#%p#%t#%n#'
    # include bounding box
    fl_box = ' %1.5f %1.5f %1.5f %1.5f %1.5f %1.5f ' % (xmin, xmax, ymin, ymax, zmin, zmax)
    fl_file = name

    flag = fl_opt + fl_box + fl_file
    # execute voro++
    call([flag], shell=True)

    # create a voronoi object
    vdat = VoroData(lat_pnt)

    # open the file generated by voro++
    fid = open(name + '.vol', 'r')
    # file where results are
    dat = fid.readlines()

    ind_basis = 0
    for ind_1 in range(len(lat_pnt.lat.typ)):
        for ind_2 in range(lat_pnt.lat.typ[ind_1]):
                ip = lat_pnt.basis_coord[ind_1][ind_2]
                for dlin in dat:
                    ind = allindices(dlin, '#')
                    ind_pnt = int(dlin[0:ind[0]])

                    if ind_pnt == ip:
                        num_v = int(dlin[(ind[0] + 1):ind[1]])
                        num_e = int(dlin[(ind[1] + 1):ind[2]])
                        num_f = int(dlin[(ind[2] + 1):ind[3]])
                        # store results in polyhedra
                        vdat.polyhedra_type[ind_basis] = np.array([num_f, num_e, num_v], dtype=int)

                        vert = np.zeros([num_v, 3])
                        re_text = dlin[(ind[3]+1):ind[4]].split()
                        for ind_v in range(num_v):
                            # recover all positions of the vertices
                            val = re.findall(r'[+-]? *(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+)?', re_text[ind_v])
                            for ind_s, v_num in enumerate(val):
                                xval = float(v_num)
                                vert[ind_v, ind_s] = xval
                        vdat.vertices[ind_basis] = vert
                        # recover all faces
                        re_text = dlin[(ind[4]+1):ind[5]].split()
                        v_list = []
                        for ind_f in range(num_f):
                            tval = tuple(eval(str(re_text[ind_f])))
                            v_list.append(np.array(tval))
                        vdat.regions[ind_basis] = v_list
                        # neighbors
                        re_text = dlin[(ind[5]+1):ind[6]].split()
                        nn_list = []
                        for ind_n in re_text:
                            nn_list.append(int(ind_n))
                        nn = np.array(nn_list)
                        vdat.neighs_id[ind_basis] = nn
                        vdat.neighs[ind_basis] = lat_pnt.pnts[nn]
                        vdat.neighs_rad[ind_basis] = lat_pnt.lat.radius[lat_pnt.indices_all[nn, 0]]
                        ind_basis += 1
    fid.close()

    return vdat


def allindices(string, sub, listindex=None, offset=0):
    """returns all the indices where a given character appears

    :param string: string
    :param sub: character to be localized
    :param listindex: list containing the position
    :param offset: starting point for the search
    :return: list of all occurences of a character
    :rtype: list
    """

    if listindex is None:
        listindex = []

    i = string.find(sub, offset)
    while i >= 0:
        listindex.append(i)
        i = string.find(sub, i + 1)
    return listindex
